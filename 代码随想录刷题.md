# 数组专题

#### 数组的基础知识

定义：数组是存放在连续内存空间上的相同类型数据的集合

- 数组下标都是从0开始的
- 数组内空间地址是连续的
- 正是因为数组的内存空间地址是连续的，所以我们在删除或者添加元素的适合，无法避免移动其它元素





#### 二分查找类型题

##### 题目1（leetcode 704）

- 排序数组
- 查找元素

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220424145732827.png" alt="image-20220424145732827" style="zoom: 80%;" />

```java
写法1
class Solution {
    public int search(int[] nums, int target) {
        int left=0;
        int right=nums.length-1;
        while(right>=left){
            int mid = (left+right)/2;
            if(nums[mid]<target){
                left = mid+1;
            }else if(nums[mid]>target){
                right=mid-1;
            }else{
                return mid;
            }
        }
        return -1;
    }
}
```

- 二分查找的两种写法

  这两个写法的区别在于循环终止条件和右指针是移动到mid位置还是移动到其前一个

  - 左右都闭合（左指针和右指针都指在元素本身）
    - 在这种写法中，如果两个指针都指向同一元素，那么这个元素也是要被搜寻的（例如遍历单元素数组的时候，左右指针都指向第一个元素，这时候也要进入循环进行结果的判断）并且如果中间元素不是target的话需要将右指针指向mid的前一个，因为mid已经被检验完成了
      - **这里循环的终止条件应该是while (left <= right) 要使用 <=**
      - **这里的右指针移动需要将其移动到mid的下一个**
  - 左闭右开（左指针指向的是元素本身，右指针指向的是所有元素的下一个）
    - 在这种写法中，右指针指向的元素永远是有效元素的后一个，所以当左指针和右指针相碰，这就说明并没有有效的搜索集了，并且当mid并不等于target的时候，我们也要保持在有效搜索范围外一个的位置上定义我们的右指针
      - **while (left < right)，这里使用 <**
      - **if (nums[middle] > target) right 更新为 middle**

  

```java
写法2
class Solution {
    public int search(int[] nums, int target) {
        int left=0;
        int right=nums.length;
        while(right>left){
            int mid = (left+right)/2;
            if(nums[mid]<target){
                left = mid+1;
            }else if(nums[mid]>target){
                right=mid;
            }else{
                return mid;
            }
        }
        return -1;
    }
}
```

**从这比较中可以看出来，定义右指针的方式不同，循环结束条件不同，右指针移动的时候的位置不同（三不同）**



##### 题目2: 35搜索插入位置

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220424154416512.png" alt="image-20220424154416512" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220424154537055.png" alt="image-20220424154537055" style="zoom:80%;" />

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length-1;
        while(left<=right){
            int mid = (left+right)/2;
            if(nums[mid]<target){
                left = mid+1;
            }else if(nums[mid]>target){
                right = mid-1;
            }else{
                return mid;
            }
        }
        return left;
    }
}
```

**与上面不一样的就是返回值**

在双闭合写法的时候，当搜寻结束时，右指针会在左指针的左侧（只能返回左）。

而在单闭合写法的时候，最后结束的时候就时左右指针重合（所以返回左还是右都可以）



#### 移除元素

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220425142044037.png" alt="image-20220425142044037" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220425142056729.png" alt="image-20220425142056729" style="zoom:80%;" />

##### 题目1（leetcode 27）快慢指针类型题

慢指针指向的是返回数据集的右边界，快指针遍历数据集中的每一个元素，当快指针指向的元素和val不一样的时候，将右边界指向的元素和当前元素调换，之后右边界往后扩一个。如果一样则右边界不动继续找下一个与val不一样的元素。

这道题的右边界思想和二分查找解法的第二种解法相同。我们右边界定位0的时候，这时候叫右边界（返回数据集的右边的一个位置）当右边界为-1的时候，这时候才是指向的元素

**解法1：右边界解法（返回数据集的下一个位置）**

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int returnIndex = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]!=val){
                swep(nums,returnIndex,i);
                returnIndex++;
            }
        }
        return returnIndex;
    }
    public void swep(int[] nums,int index1,int index2){
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp; 

    }
}
```

**解法2：右指向返回集合的最后一个元素**

与上一种对比，当一开始的时候，我们的慢指针不能指向0位置，因为0位置上的数我们并不知道是否要返回。而是要指向-1位置，因为-1位置才是我们要返回数据集中的第一个数

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int returnIndex = -1;
        for(int i=0;i<nums.length;i++){
            if(nums[i]!=val){
                swep(nums,returnIndex+1,i);
                returnIndex++;
            }
        }
        return returnIndex+1;
    }
    public void swep(int[] nums,int index1,int index2){
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp; 

    }
}
```

##### 题目2（leetcode844）比较含退格字符串

这道题中的思想就是，字符串和数组是一样的东西，都是连续存储空间的一种数据结构

这道题比上一题多了一个往后退的思想，当遇到#的时候，就得让选中区域往后移动一个格。但是要注意，当已经不能移动的时候就不要移动它了，

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220425154135837.png" alt="image-20220425154135837" style="zoom:80%;" />

```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        char[] s1 = s.toCharArray();
        char[] s2 = t.toCharArray();
        int indexS1=0;
        int indexS2=0;
        indexS2=stringChange(s2,indexS2);
        indexS1=stringChange(s1,indexS1);
        
        if(indexS1==indexS2){
            for(int i=0;i<indexS1;i++){
                if(s1[i]!=s2[i]){
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    public void swep(char[] nums,int index1,int index2){
        char temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp; 

    }
    public static int stringChange(char[] s1,int indexS1){
//        设置向后扩的右边界，当是非删除字符的时候就往后扩，当是删除祝福的时候就往前缩，当缩不了就不动
        for(int i=0;i<s1.length;i++){
            if(s1[i]=='#'&&indexS1!=0){
                indexS1--;
            }else if(s1[i]=='#'&&indexS1==0){
                continue;
            }else{
                swep(s1,indexS1,i);
                indexS1++;
            }
        }
        return indexS1;
    }
}
```

#### 有序数组的平方

##### 题目1：有序数组的平方leetcode977·

![image-20220426150147438](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220426150147438.png)

题目分析：将数组分为两端，之后用两个指针分别操作这两端的东西到一个新的数组中，像merge过程。

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] res = new int[nums.length];
        int positiveNumIndex = 0;
        for(int i =0;i<nums.length;i++){
            if(nums[i]<0){
                positiveNumIndex++;
            }else{
                break;
            }
        }
        int negNumIndex = positiveNumIndex-1;
        for(int i =0;i<res.length;i++){
            if(positiveNumIndex<nums.length&&negNumIndex>=0){
                if(nums[positiveNumIndex]<=-nums[negNumIndex]){
                    res[i]=nums[positiveNumIndex]*nums[positiveNumIndex];
                    positiveNumIndex++;
                }else{
                    res[i]=nums[negNumIndex]*nums[negNumIndex];
                    negNumIndex--;
                }
            }else{
                if(positiveNumIndex<nums.length){
                    res[i]=nums[positiveNumIndex]*nums[positiveNumIndex];
                    positiveNumIndex++;
                }
                if(negNumIndex>=0){
                    res[i]=nums[negNumIndex]*nums[negNumIndex];
                    negNumIndex--;
                }
            }
        }
        return res;
    }
}
```

#### 滑动窗口类型题

与上面使用指针的不同，滑动窗口往往对一些集合类的东西进行操作

##### 题目1：长度最小的子数组

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220426151107339.png" alt="image-20220426151107339" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220426151317698.png" alt="image-20220426151317698" style="zoom:80%;" />

注意审题，这里面是让我们找出来大于等于的组合，而不仅限于等于。

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int subArrLength=Integer.MAX_VALUE;
        int leftIndex = 0;
        int rightIndex = 0;
        int subArrSum = 0;
        while(rightIndex<nums.length){
            subArrSum += nums[rightIndex++];
            while(subArrSum>=target){
                subArrLength =  Math.min(subArrLength,rightIndex-leftIndex);
                subArrSum-=nums[leftIndex++];
            }
        }
        return subArrLength==Integer.MAX_VALUE?0:subArrLength;
    }
}
```

##### 题目2：水果成篮Leetcode904

使用哈希表来控制左指针的移动

```java
class Solution {
    public int totalFruit(int[] fruits) {
        // int typeCount = 0;
        int leftPoint = 0;
        int returnSum = 0;
        // int returnSumtemp = 0;
        HashMap<Integer,Integer> recording = new HashMap<>();
        for(int rightPoint = 0; rightPoint<fruits.length ;rightPoint++){
            if(!recording.containsKey(fruits[rightPoint])&&recording.size()<2){
                recording.put(fruits[rightPoint],0);
            }
            if(recording.containsKey(fruits[rightPoint])){
                int recordNum = recording.get(fruits[rightPoint]);
                recording.put(fruits[rightPoint],recordNum+1);
            }
            if(!recording.containsKey(fruits[rightPoint])&&recording.size()==2){
                returnSum = Math.max(returnSum,rightPoint-leftPoint);
                while(recording.get(fruits[leftPoint])!=0){
                    int recordNumRem = recording.get(fruits[leftPoint]);
                    recording.replace(fruits[leftPoint],--recordNumRem);
                    if(recording.get(fruits[leftPoint])==0){
                        recording.remove(fruits[leftPoint]);
                        leftPoint++;
                        rightPoint--;
                        break;
                    }
                    leftPoint++;
                }
            }
            returnSum = Math.max(returnSum,rightPoint-leftPoint+1);
        }
        
        return returnSum;
    }
}
```

##### 小总结：最小滑动窗口模板和最大滑动窗口模板

- 最大最小不是指的是具体的值，而是窗口内的元素个数是需要最少的个数还是需要最大的个数

当要求最小的时候使用最小滑动窗口，最小滑动窗口的模板如下

i和j分别是左右边界，最小滑动窗口模板是在缩短i的同时进行元素更新的，因为如果i缩短了，那么可能会成为最小值

```java
while j < len(nums):
    判断[i, j]是否满足条件
    while 满足条件：
        不断更新结果(注意在while内更新！)
        i += 1 （最大程度的压缩i，使得滑窗尽可能的小）
    j += 1

```

最大滑动窗口模板如下

其不同的是在不断缩短左边界之后当再区间再次满足条件的时候再更新

```java
while j < len(nums):
    判断[i, j]是否满足条件
    while 不满足条件：
        i += 1 （最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大）
    不断更新结果（注意在while外更新！）
    j += 1

```

##### 题目3.leetcode485最大连续1的个数

与滑动窗口不同，滑动窗口题目中窗口内每一个元素的增减都会影响到是否满足条件。而这道题不存在窗口问题，因为只要元素不是1那么就需要进行操作，这与前面的元素并没有关系。这道题可以使用快慢指针。也可以通过一个变量来进行数值的记录。

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220428161004093.png" alt="image-20220428161004093" style="zoom:80%;" />

解法1：（慢指针记录起始位置快指针往前跑）

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int slowPoint = 0;
        int sumCount = 0;
        int returnSum = 0;
        for(int fastPoint = 0;fastPoint<nums.length;fastPoint++){
            if(nums[fastPoint]==1){
                sumCount=fastPoint-slowPoint+1;
            }else{
                slowPoint=fastPoint+1;
                sumCount = 0;
            }
            returnSum = Math.max(returnSum,sumCount);
        }
        return returnSum;
    }
}
```

解法2

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        // int leftPoint = 0;
        int rightPoint = 0;
        int sumNum1 = 0;
        int returnSum =0;
        while(rightPoint<nums.length){
            if(nums[rightPoint]==1){
                rightPoint+=1;
                sumNum1+=1;
                returnSum=Math.max(sumNum1,returnSum);
            }else{
                rightPoint+=1;
                sumNum1=0;
                continue;
            }
        }
        return returnSum;
    }
}
```

题目4：最大连续1的个数（三指针）

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220428170116586.png" alt="image-20220428170116586" style="zoom:80%;" />

一个指针往前跑，第二个指针记录第三个指针下一次去的位置，第三个指针作为数据集的下界和第一个指针形成数据集窗口

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int slowPoint = 0;
        int slowPoint2 = 0;
        int sumCount = 0;
        int returnSum = 0;
        int Convert0 = 0;
        for(int fastPoint = 0;fastPoint<nums.length;fastPoint++){
            if(nums[fastPoint]==1){
                sumCount=fastPoint-slowPoint2+1;
            }else if(nums[fastPoint]!=1&&Convert0==0){
                slowPoint=fastPoint+1;
                Convert0=1;
                sumCount+=1;
                // sumCount = 0;
            }else if(nums[fastPoint]!=1&&Convert0==1){
                slowPoint2=slowPoint;
                slowPoint=fastPoint+1;
                sumCount = 0;
                // Convert0=0;
            }
            returnSum = Math.max(returnSum,sumCount);
        }
        return returnSum;
    }
}
```

##### 题目4：leetcode1004最大连续1的个数III

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220429160530762.png" alt="image-20220429160530762" style="zoom:80%;" />

最大窗口例题,满足在左边界左移后进行数据统计

```java
class Solution {
    public int longestOnes(int[] nums, int k) {
        int rightPoint = 0;
        int leftPoint = 0;
        int count0 = 0;
        int returnCount1=0;
        int finalreCount1 = 0;
        while(rightPoint<nums.length){
            if(nums[rightPoint]==1){
                returnCount1++;
                rightPoint++;
            }
            else if(count0<k && nums[rightPoint]==0){
                count0++;
                returnCount1++;
                rightPoint++;
            }
            else if(count0>=k && nums[rightPoint]==0){
                while(nums[leftPoint]!=0){
                    returnCount1--;
                    leftPoint++;
                }
                returnCount1--;
                leftPoint++;
                count0--;
            }
            finalreCount1 = Math.max(finalreCount1,returnCount1);
        }
        return finalreCount1;
    }
}
```

#### 2D矩阵

##### 题目1：leetcode054：spiral Matrix（螺旋矩阵）

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220509163332510.png" alt="image-20220509163332510" style="zoom: 80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220509163400503.png" alt="image-20220509163400503" style="zoom:80%;" />

解：

分层模拟法

![image-20220509163517922](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220509163517922.png)

上：起始就是从（top，left）终止（top，right）

右：起始从（top+1，right）终止（bottom，right）



下：起始（bottom，right-1）终止（bottom，left+1）

左：起始（bottom，left）终止（top+1，left）

起始时用for循环中的变量起始条件来判断的，终止是用for循环的终止条件判断的

上右的边界条件没有+1，这就说明可以使用一个闭区间即带等于号即可

下左边界条件右加1，所以这时候需要开区间即不带等于号

当进入下左条件的时候我们要判断是否能出来新的一行或者一列，避免在原有的行列中继续循环

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        if(matrix==null || matrix.length==0 || matrix[0].length==0){
            return res;
        }
        int row = matrix.length;
        int col = matrix[0].length;
        int left = 0;
        int right = col - 1;
        int top = 0;
        int bottom = row - 1;
        // 当左指针超过了右指针停下，同理上指针超过了下指针停下
        // 由于右指针和下指针是有意义的闭区间，所以要有等于号
        while(left<=right && top <= bottom){
            for(int i = left; i<=right;i++){
                res.add(matrix[top][i]);
            }
            for (int row1 = top + 1; row1 <= bottom; row1++) {
                res.add(matrix[row1][right]);
            }

            if (left < right && top < bottom) {
                for(int k = right-1 ; k > left ; k--){
                    res.add(matrix[bottom][k]);
                }
                for(int x = bottom ; x> top;x--){
                    res.add(matrix[x][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
    return res;
    }
}
```

