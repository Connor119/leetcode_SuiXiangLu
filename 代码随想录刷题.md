# 数组专题

#### 数组的基础知识

定义：数组是存放在连续内存空间上的相同类型数据的集合

- 数组下标都是从0开始的
- 数组内空间地址是连续的
- 正是因为数组的内存空间地址是连续的，所以我们在删除或者添加元素的适合，无法避免移动其它元素





#### 二分查找类型题

##### 题目1（leetcode 704）

- 排序数组
- 查找元素

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220424145732827.png" alt="image-20220424145732827" style="zoom: 80%;" />

```java
写法1
class Solution {
    public int search(int[] nums, int target) {
        int left=0;
        int right=nums.length-1;
        while(right>=left){
            int mid = (left+right)/2;
            if(nums[mid]<target){
                left = mid+1;
            }else if(nums[mid]>target){
                right=mid-1;
            }else{
                return mid;
            }
        }
        return -1;
    }
}
```

- 二分查找的两种写法

  这两个写法的区别在于循环终止条件和右指针是移动到mid位置还是移动到其前一个

  - 左右都闭合（左指针和右指针都指在元素本身）
    - 在这种写法中，如果两个指针都指向同一元素，那么这个元素也是要被搜寻的（例如遍历单元素数组的时候，左右指针都指向第一个元素，这时候也要进入循环进行结果的判断）并且如果中间元素不是target的话需要将右指针指向mid的前一个，因为mid已经被检验完成了
      - **这里循环的终止条件应该是while (left <= right) 要使用 <=**
      - **这里的右指针移动需要将其移动到mid的下一个**
  - 左闭右开（左指针指向的是元素本身，右指针指向的是所有元素的下一个）
    - 在这种写法中，右指针指向的元素永远是有效元素的后一个，所以当左指针和右指针相碰，这就说明并没有有效的搜索集了，并且当mid并不等于target的时候，我们也要保持在有效搜索范围外一个的位置上定义我们的右指针
      - **while (left < right)，这里使用 <**
      - **if (nums[middle] > target) right 更新为 middle**

  

```java
写法2
class Solution {
    public int search(int[] nums, int target) {
        int left=0;
        int right=nums.length;
        while(right>left){
            int mid = (left+right)/2;
            if(nums[mid]<target){
                left = mid+1;
            }else if(nums[mid]>target){
                right=mid;
            }else{
                return mid;
            }
        }
        return -1;
    }
}
```

**从这比较中可以看出来，定义右指针的方式不同，循环结束条件不同，右指针移动的时候的位置不同（三不同）**



##### 题目2: 35搜索插入位置

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220424154416512.png" alt="image-20220424154416512" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220424154537055.png" alt="image-20220424154537055" style="zoom:80%;" />

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length-1;
        while(left<=right){
            int mid = (left+right)/2;
            if(nums[mid]<target){
                left = mid+1;
            }else if(nums[mid]>target){
                right = mid-1;
            }else{
                return mid;
            }
        }
        return left;
    }
}
```

**与上面不一样的就是返回值**

在双闭合写法的时候，当搜寻结束时，右指针会在左指针的左侧（只能返回左）。

而在单闭合写法的时候，最后结束的时候就时左右指针重合（所以返回左还是右都可以）



#### 移除元素

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220425142044037.png" alt="image-20220425142044037" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220425142056729.png" alt="image-20220425142056729" style="zoom:80%;" />

##### 题目1（leetcode 27）快慢指针类型题

慢指针指向的是返回数据集的右边界，快指针遍历数据集中的每一个元素，当快指针指向的元素和val不一样的时候，将右边界指向的元素和当前元素调换，之后右边界往后扩一个。如果一样则右边界不动继续找下一个与val不一样的元素。

这道题的右边界思想和二分查找解法的第二种解法相同。我们右边界定位0的时候，这时候叫右边界（返回数据集的右边的一个位置）当右边界为-1的时候，这时候才是指向的元素

**解法1：右边界解法（返回数据集的下一个位置）**

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int returnIndex = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]!=val){
                swep(nums,returnIndex,i);
                returnIndex++;
            }
        }
        return returnIndex;
    }
    public void swep(int[] nums,int index1,int index2){
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp; 

    }
}
```

**解法2：右指向返回集合的最后一个元素**

与上一种对比，当一开始的时候，我们的慢指针不能指向0位置，因为0位置上的数我们并不知道是否要返回。而是要指向-1位置，因为-1位置才是我们要返回数据集中的第一个数

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int returnIndex = -1;
        for(int i=0;i<nums.length;i++){
            if(nums[i]!=val){
                swep(nums,returnIndex+1,i);
                returnIndex++;
            }
        }
        return returnIndex+1;
    }
    public void swep(int[] nums,int index1,int index2){
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp; 

    }
}
```

##### 题目2（leetcode844）比较含退格字符串

这道题中的思想就是，字符串和数组是一样的东西，都是连续存储空间的一种数据结构

这道题比上一题多了一个往后退的思想，当遇到#的时候，就得让选中区域往后移动一个格。但是要注意，当已经不能移动的时候就不要移动它了，

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220425154135837.png" alt="image-20220425154135837" style="zoom:80%;" />

```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        char[] s1 = s.toCharArray();
        char[] s2 = t.toCharArray();
        int indexS1=0;
        int indexS2=0;
        indexS2=stringChange(s2,indexS2);
        indexS1=stringChange(s1,indexS1);
        
        if(indexS1==indexS2){
            for(int i=0;i<indexS1;i++){
                if(s1[i]!=s2[i]){
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    public void swep(char[] nums,int index1,int index2){
        char temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp; 

    }
    public static int stringChange(char[] s1,int indexS1){
//        设置向后扩的右边界，当是非删除字符的时候就往后扩，当是删除祝福的时候就往前缩，当缩不了就不动
        for(int i=0;i<s1.length;i++){
            if(s1[i]=='#'&&indexS1!=0){
                indexS1--;
            }else if(s1[i]=='#'&&indexS1==0){
                continue;
            }else{
                swep(s1,indexS1,i);
                indexS1++;
            }
        }
        return indexS1;
    }
}
```

#### 有序数组的平方

##### 题目1：有序数组的平方leetcode977·

![image-20220426150147438](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220426150147438.png)

题目分析：将数组分为两端，之后用两个指针分别操作这两端的东西到一个新的数组中，像merge过程。

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] res = new int[nums.length];
        int positiveNumIndex = 0;
        for(int i =0;i<nums.length;i++){
            if(nums[i]<0){
                positiveNumIndex++;
            }else{
                break;
            }
        }
        int negNumIndex = positiveNumIndex-1;
        for(int i =0;i<res.length;i++){
            if(positiveNumIndex<nums.length&&negNumIndex>=0){
                if(nums[positiveNumIndex]<=-nums[negNumIndex]){
                    res[i]=nums[positiveNumIndex]*nums[positiveNumIndex];
                    positiveNumIndex++;
                }else{
                    res[i]=nums[negNumIndex]*nums[negNumIndex];
                    negNumIndex--;
                }
            }else{
                if(positiveNumIndex<nums.length){
                    res[i]=nums[positiveNumIndex]*nums[positiveNumIndex];
                    positiveNumIndex++;
                }
                if(negNumIndex>=0){
                    res[i]=nums[negNumIndex]*nums[negNumIndex];
                    negNumIndex--;
                }
            }
        }
        return res;
    }
}
```

#### 滑动窗口类型题

与上面使用指针的不同，滑动窗口往往对一些集合类的东西进行操作

##### 题目1：长度最小的子数组

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220426151107339.png" alt="image-20220426151107339" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220426151317698.png" alt="image-20220426151317698" style="zoom:80%;" />

注意审题，这里面是让我们找出来大于等于的组合，而不仅限于等于。

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int subArrLength=Integer.MAX_VALUE;
        int leftIndex = 0;
        int rightIndex = 0;
        int subArrSum = 0;
        while(rightIndex<nums.length){
            subArrSum += nums[rightIndex++];
            while(subArrSum>=target){
                subArrLength =  Math.min(subArrLength,rightIndex-leftIndex);
                subArrSum-=nums[leftIndex++];
            }
        }
        return subArrLength==Integer.MAX_VALUE?0:subArrLength;
    }
}
```

##### 题目2：水果成篮Leetcode904

使用哈希表来控制左指针的移动

```java
class Solution {
    public int totalFruit(int[] fruits) {
        // int typeCount = 0;
        int leftPoint = 0;
        int returnSum = 0;
        // int returnSumtemp = 0;
        HashMap<Integer,Integer> recording = new HashMap<>();
        for(int rightPoint = 0; rightPoint<fruits.length ;rightPoint++){
            if(!recording.containsKey(fruits[rightPoint])&&recording.size()<2){
                recording.put(fruits[rightPoint],0);
            }
            if(recording.containsKey(fruits[rightPoint])){
                int recordNum = recording.get(fruits[rightPoint]);
                recording.put(fruits[rightPoint],recordNum+1);
            }
            if(!recording.containsKey(fruits[rightPoint])&&recording.size()==2){
                returnSum = Math.max(returnSum,rightPoint-leftPoint);
                while(recording.get(fruits[leftPoint])!=0){
                    int recordNumRem = recording.get(fruits[leftPoint]);
                    recording.replace(fruits[leftPoint],--recordNumRem);
                    if(recording.get(fruits[leftPoint])==0){
                        recording.remove(fruits[leftPoint]);
                        leftPoint++;
                        rightPoint--;
                        break;
                    }
                    leftPoint++;
                }
            }
            returnSum = Math.max(returnSum,rightPoint-leftPoint+1);
        }
        
        return returnSum;
    }
}
```

##### 小总结：最小滑动窗口模板和最大滑动窗口模板

- 最大最小不是指的是具体的值，而是窗口内的元素个数是需要最少的个数还是需要最大的个数

当要求最小的时候使用最小滑动窗口，最小滑动窗口的模板如下

i和j分别是左右边界，最小滑动窗口模板是在缩短i的同时进行元素更新的，因为如果i缩短了，那么可能会成为最小值

```java
while j < len(nums):
    判断[i, j]是否满足条件
    while 满足条件：
        不断更新结果(注意在while内更新！)
        i += 1 （最大程度的压缩i，使得滑窗尽可能的小）
    j += 1

```

最大滑动窗口模板如下

其不同的是在不断缩短左边界之后当再区间再次满足条件的时候再更新

```java
while j < len(nums):
    判断[i, j]是否满足条件
    while 不满足条件：
        i += 1 （最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大）
    不断更新结果（注意在while外更新！）
    j += 1

```

##### 题目3.leetcode485最大连续1的个数

与滑动窗口不同，滑动窗口题目中窗口内每一个元素的增减都会影响到是否满足条件。而这道题不存在窗口问题，因为只要元素不是1那么就需要进行操作，这与前面的元素并没有关系。这道题可以使用快慢指针。也可以通过一个变量来进行数值的记录。

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220428161004093.png" alt="image-20220428161004093" style="zoom:80%;" />

解法1：（慢指针记录起始位置快指针往前跑）

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int slowPoint = 0;
        int sumCount = 0;
        int returnSum = 0;
        for(int fastPoint = 0;fastPoint<nums.length;fastPoint++){
            if(nums[fastPoint]==1){
                sumCount=fastPoint-slowPoint+1;
            }else{
                slowPoint=fastPoint+1;
                sumCount = 0;
            }
            returnSum = Math.max(returnSum,sumCount);
        }
        return returnSum;
    }
}
```

解法2

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        // int leftPoint = 0;
        int rightPoint = 0;
        int sumNum1 = 0;
        int returnSum =0;
        while(rightPoint<nums.length){
            if(nums[rightPoint]==1){
                rightPoint+=1;
                sumNum1+=1;
                returnSum=Math.max(sumNum1,returnSum);
            }else{
                rightPoint+=1;
                sumNum1=0;
                continue;
            }
        }
        return returnSum;
    }
}
```

题目4：最大连续1的个数（三指针）

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220428170116586.png" alt="image-20220428170116586" style="zoom:80%;" />

一个指针往前跑，第二个指针记录第三个指针下一次去的位置，第三个指针作为数据集的下界和第一个指针形成数据集窗口

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int slowPoint = 0;
        int slowPoint2 = 0;
        int sumCount = 0;
        int returnSum = 0;
        int Convert0 = 0;
        for(int fastPoint = 0;fastPoint<nums.length;fastPoint++){
            if(nums[fastPoint]==1){
                sumCount=fastPoint-slowPoint2+1;
            }else if(nums[fastPoint]!=1&&Convert0==0){
                slowPoint=fastPoint+1;
                Convert0=1;
                sumCount+=1;
                // sumCount = 0;
            }else if(nums[fastPoint]!=1&&Convert0==1){
                slowPoint2=slowPoint;
                slowPoint=fastPoint+1;
                sumCount = 0;
                // Convert0=0;
            }
            returnSum = Math.max(returnSum,sumCount);
        }
        return returnSum;
    }
}
```

##### 题目4：leetcode1004最大连续1的个数III

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220429160530762.png" alt="image-20220429160530762" style="zoom:80%;" />

最大窗口例题,满足在左边界左移后进行数据统计

```java
class Solution {
    public int longestOnes(int[] nums, int k) {
        int rightPoint = 0;
        int leftPoint = 0;
        int count0 = 0;
        int returnCount1=0;
        int finalreCount1 = 0;
        while(rightPoint<nums.length){
            if(nums[rightPoint]==1){
                returnCount1++;
                rightPoint++;
            }
            else if(count0<k && nums[rightPoint]==0){
                count0++;
                returnCount1++;
                rightPoint++;
            }
            else if(count0>=k && nums[rightPoint]==0){
                while(nums[leftPoint]!=0){
                    returnCount1--;
                    leftPoint++;
                }
                returnCount1--;
                leftPoint++;
                count0--;
            }
            finalreCount1 = Math.max(finalreCount1,returnCount1);
        }
        return finalreCount1;
    }
}
```

#### 2D矩阵

##### 题目1：leetcode054：spiral Matrix（螺旋矩阵）

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220509163332510.png" alt="image-20220509163332510" style="zoom: 80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220509163400503.png" alt="image-20220509163400503" style="zoom:80%;" />

解：

分层模拟法

![image-20220509163517922](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220509163517922.png)

上：起始就是从（top，left）终止（top，right）

右：起始从（top+1，right）终止（bottom，right）



下：起始（bottom，right-1）终止（bottom，left+1）

左：起始（bottom，left）终止（top+1，left）

起始时用for循环中的变量起始条件来判断的，终止是用for循环的终止条件判断的

上右的边界条件没有+1，这就说明可以使用一个闭区间即带等于号即可

下左边界条件右加1，所以这时候需要开区间即不带等于号

当进入下左条件的时候我们要判断是否能出来新的一行或者一列，避免在原有的行列中继续循环

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        if(matrix==null || matrix.length==0 || matrix[0].length==0){
            return res;
        }
        int row = matrix.length;
        int col = matrix[0].length;
        int left = 0;
        int right = col - 1;
        int top = 0;
        int bottom = row - 1;
        // 当左指针超过了右指针停下，同理上指针超过了下指针停下
        // 由于右指针和下指针是有意义的闭区间，所以要有等于号
        while(left<=right && top <= bottom){
            for(int i = left; i<=right;i++){
                res.add(matrix[top][i]);
            }
            for (int row1 = top + 1; row1 <= bottom; row1++) {
                res.add(matrix[row1][right]);
            }

            if (left < right && top < bottom) {
                for(int k = right-1 ; k > left ; k--){
                    res.add(matrix[bottom][k]);
                }
                for(int x = bottom ; x> top;x--){
                    res.add(matrix[x][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
    return res;
    }
}
```

##### 题目2：leetcode059 spiral Matrix II（旋转矩阵2）

与上一题思路一样

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220510154217646.png" alt="image-20220510154217646" style="zoom: 67%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220510154237618.png" alt="image-20220510154237618" style="zoom:67%;" />

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] res = new int[n][n];
        if(n==0){
            return res;
        }
        int count=1;
        int row = res.length;
        int col = res[0].length;
        int top = 0;
        int bottom = row-1;
        int left = 0;
        int right = col-1;
        while(left<=right&&top<=bottom){
            for(int i=left;i<=right;i++){
                res[top][i]=count;
                count++;
            }
             for (int row1 = top + 1; row1 <= bottom; row1++) {
                res[row1][right]=count;
                count++;
            }
            if(left<right&&top<bottom){
                for(int j=right-1;j>left;j--){
                    res[bottom][j]=count;
                    count++;
                }
                for(int x = bottom ; x> top;x--){
                    res[x][left]=count;
                    count++;
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
        return res;
    }
}
```

# 链表专题

#### 虚拟头节点问题

##### 题目1：leetcode203：移除链表的元素

这种手段是用来解决处理头节点的时候逻辑与处理其它节点不一样的时提出的。

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220510160244117.png" alt="image-20220510160244117" style="zoom:67%;" />

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head==null){
            return head;
        }
        // 新建一个节点作为虚拟头节点
        ListNode dunnyHead = new ListNode(1);
        dunnyHead.next = head;
        ListNode pre = dunnyHead;
        ListNode cur = head;
        while(cur!=null){
            if(cur.val==val){
                pre.next = cur.next;
            }else{
                pre = cur;
            }
            cur = cur.next;
        }
        return dunnyHead.next;
    }
}
```

当我们删除一个元素的时候的逻辑是：检查当前元素的值是否与val相等，如果是相等的，那么这时候通过前一个指针的指向将当前元素丢弃。而如果不使用虚拟头节点，南无只能将pre指针定在head上，而cur指针在head.next上出现。这导致了头节点没有被检查。所以这时候需要设置虚拟头节点。

#### 链表的设计

##### 题目1：leetcode707：链表的设计

![image-20220510161031438](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220510161031438.png)

```java
class MyLinkedList {
//     class Node {
//     int val;
//     Node next;
//     Node() {}
//     Node(int val) { this.val = val; }
//     Node(int val, Node next) { this.val = val; this.next = next; }
// }
    public class Node{
        int val;
        Node next;
        public Node(int value){
            this.val = value;
        }
    }

    Node dunnyHead = new Node(-1);
    int size = 0;
    public MyLinkedList() {

    }
    
    public int get(int index) {
        if(index<0 || index >= size){
            return -1;
        }
        Node temp = dunnyHead;
        int count = 0;
        while(count<=index){
            temp=temp.next;
            count++;
        }
        return temp.val;
    }
    
    public void addAtHead(int val) {
        addAtIndex(0,val);
    }
    
    public void addAtTail(int val) {
        addAtIndex(size,val);
    }
    
    public void addAtIndex(int index, int val) {
        Node newNode = new Node(val);
        // Node cur = dunnyHead.next;
        Node pre = dunnyHead;
        // int count = 0;
        if(index>size){
            return;
        }
        if(index<0){
            index=0;
        }
        // while(count<index){
        //     pre=cur;
        //     cur=cur.next;
        //     count++;
        // }
        for (int i = 0; i < index; i++) {
            pre = pre.next;
        }
        // pre.next = newNode;
        // newNode.next = cur;
        newNode.next = pre.next;
        pre.next = newNode;
        size++;
    }
    
    public void deleteAtIndex(int index) {
        //写法1
        if (index < 0 || index >= size) {
            return;
        }
        size--;
        Node pred = dunnyHead;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }
        pred.next = pred.next.next;
        //写法2
        // if(index<0||index>=size){
        //     return;
        // }
        // Node cur = dunnyHead.next;
        // Node pre = dunnyHead;
        // int count = 0;
        // while(count<index){
        //     pre=cur;
        //     cur=cur.next;
        //     count++;
        // }
        // if(cur.next==null){
        //     pre.next = null;
        // }else{
        //      pre.next = cur.next;
        // }
        // size--;
    }
}
```

添加节点逻辑：找到要添加位置的前一个，这时候循环没有等号，等号则是让某个指针指向index位置，没有等号则是指向index签名一个位置。这就如我们使用数组长度为边界进行遍历时一样，我们并不想让其越界。这时候我们不能加等号。

删除逻辑：当一个节点存在，而这个节点的next时null的时候，使用.next不会报错，只有这个节点是null而null的.next是没有的这时候才会报错。主要处理逻辑是判断是否index越界，在不越界的情况下让pre。next直接指向其pre.next.next即可完成。

查询节点逻辑：这里如果把dunnyhead换成index0的时候会出现等于号，因为真正的head是从索引1开始的

#### 链表的反转

##### 题目1：leetcode206：链表反转

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220511155618456.png" alt="image-20220511155618456" style="zoom:67%;" />

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        // 先定义一个最尾的null
        ListNode pre = null;
        ListNode cur = head;
        while(cur!=null){
            ListNode tempNode = cur.next;
            cur.next = pre;
            pre=cur;
            cur=tempNode;
        }
        return pre;
    }
}
```

最后返回的应该是pre而不是cur，因为cur最后一定会跑到null上，而pre会在链表的新的头上

#### 两两交换链表中的节点

##### 题目1leetcode24：两两交换链表中的节点（swapPairs）

题解思路：

![image-20220511160617677](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220511160617677.png)

链表题目一定要画图，这道题中首先需要记录下我们所需要操作节点的所有索引，之后在此基础上实现上图的三个步骤。

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dunnyHead = new ListNode(-1);
        dunnyHead.next=head;
        ListNode cur = dunnyHead;
        while(cur.next!=null&&cur.next.next!=null){
            ListNode node1 = cur.next;
            ListNode node2 = cur.next.next;
            ListNode nextparir = node2.next;
            cur.next = node2;
            node2.next = node1;
            node1.next = nextparir;
            cur=node1;
        }
        return dunnyHead.next;
    }
}
```

#### 删除倒数第N个节点

##### 题目1：leetcode19删除链表的倒数第N个节点

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220511162357623.png" alt="image-20220511162357623" style="zoom:67%;" />

这道题目是双指针的经典应用。由于链表没有size方法，所以我们不能得知我们要删除的元素的index（由于是倒数的原因），单向链表不能往回找，所以当要操作当前节点的时候需要pre的支持。

fast（index=n的位置出发），slow（dunnyhead位置出发）

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dunnyHead = new ListNode(-1);
        dunnyHead.next=head;
        ListNode slowPoint = dunnyHead;

        ListNode fastPoint = head;
        for(int i=0;i<n;i++){
            fastPoint=fastPoint.next;
        }
        while(fastPoint!=null){
            fastPoint=fastPoint.next;
            slowPoint=slowPoint.next;
        }
        slowPoint.next = slowPoint.next.next;
        return dunnyHead.next;
    }
}
```

#### 链表相交

##### 题目1：leetcode160 链表相交

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220512155824748.png" alt="image-20220512155824748" style="zoom:67%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220512155834489.png" alt="image-20220512155834489" style="zoom:67%;" />

题目心得小结：让链表跑结束后再从头开始跑，这样相撞就是焦点。一定注意虚拟节点问题，当两个链表的头节点相交时，如果不使用虚拟节点则会造成头节点判断失误

- 方法1：不使用虚拟头节点

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode pointOne = headA;
        ListNode pointTwo = headB;
        ListNode res=null;
        int countNull=0;
        if(headA==headB){
            res=headA;
        }
        while(pointOne!=pointTwo){
            while(pointOne!=null || pointTwo!=null){
                if(pointOne==null){
                    pointOne=headB;
                    countNull++;
                }else{
                    pointOne=pointOne.next;
                }

                if(pointTwo==null){
                    pointTwo=headA;
                    countNull++;
                }else{
                    pointTwo=pointTwo.next;
                }
                
                if(pointTwo==pointOne){
                    res = pointOne;
                    break;
                }
                if(countNull>2){
                    break;
                }
            }
        }
        return res;
    }
```

- 方法2：使用虚拟头节点

```java
 public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode dunnyHead1 = new ListNode(-1);
        ListNode dunnyHead2= new ListNode(-2);
        dunnyHead1.next=headA;
        dunnyHead2.next=headB;
        ListNode pointOne = dunnyHead1;
        ListNode pointTwo = dunnyHead2;
        ListNode res=null;
        int countNull=0;
        // if(headA==headB){
        //     res=headA;
        // }
        while(pointOne!=pointTwo){
            while(pointOne!=null || pointTwo!=null){
                if(pointOne==null){
                    pointOne=headB;
                    countNull++;
                }else{
                    pointOne=pointOne.next;
                }

                if(pointTwo==null){
                    pointTwo=headA;
                    countNull++;
                }else{
                    pointTwo=pointTwo.next;
                }
                
                if(pointTwo==pointOne){
                    res = pointOne;
                    break;
                }
                if(countNull>2){
                    break;
                }
            }
        }
        return res;
    }
```

#### 链表成环

##### 题目1：剑指022链表中环的入口（快慢指针的应用）

快慢指针不是双指针，双指针问题让一个指针先跑，之后两个指针同时等距移动。这可以说是前后关系，而快慢指针则是快指针一次移动两个节点，慢指针一次移动一个节点。如果fast和slow在中途相遇，这就说明链表中有环的存在。

如果快指针和慢指针相遇则说明有环，是否有环已经判断清楚，之后需要思考如何判断环的入口。

![image-20220512161647702](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220512161647702.png)

从头节点出发一个新的节点，从相遇点出发一个新的节点，再相遇就是入口。



由于这道题头节点不可能自己成环，所以可以不用虚拟头节点

```java

public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode res = null;
        ListNode slow = head;
        ListNode fast = head;
        // if(head==null||head.next==null){
        //     return res;
        // }
        while(fast!=null){
            if(fast==null||fast.next==null||fast.next.next==null){
                return res;
            }
            slow=slow.next;
            fast=fast.next.next;
            if(fast==slow){
                ListNode point1 = slow;
                ListNode point2 = head;
                while(point1!=point2){
                    point1=point1.next;
                    point2=point2.next;
                }
                res = point1;
                break;
            }
        }
        return res;
    }
}
```

#### 链表小结

![](https://camo.githubusercontent.com/fb8a648b568e8169f50670d0d0dcdd70867bd3b3f155776bd16d6480ab361873/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f2545392539332542452545382541312541382545362538302542422545372542422539332e706e67)



## 哈希表专题

#### 了解哈希表

- 一般哈希表都用来快速判断一个元素是否出现在集合中

#### 数组当哈希表用

##### 题目1：leetcode242有效字母异位词

**小提醒：如果只有小写字母或者只有大写字母，可以使用当前字母-”a“或者-”A“来缩小定义的数组大小。如果某个字符串中的字符是不确定的，则需要定义256大小的数组，这样可以存下所有ASCII字符。我们可以直接使用字符类型的数据当作索引，其直接会帮我们转变成对应的ASCII数字。**

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220513161105034.png" alt="image-20220513161105034" style="zoom:67%;" />

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] arrRecordA = new int[256];
        int[] arrRecordB = new int[256];
        char[] schar = s.toCharArray();
        char[] tchar = t.toCharArray();
        for(char c:schar){
            arrRecordA[c]++;
        }
        for(char c:tchar){
            arrRecordB[c]++;
        }
        for(int i=0;i<256;i++){
            if(arrRecordA[i]!=arrRecordB[i]){
                return false;
            }
        }
        return true;
    }
}
```



##### 题目2：leetcode383.赎金信(之后继续做)

##### 题目3：leetcode49.字母异位词分组（之后继续做）

##### 题目4：leetcode438.找到字符串中所有字母异位词

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220513164259931.png" alt="image-20220513164259931" style="zoom:67%;" />

解：

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        int len = p.length();
        int[] recordP = new int[256];
        for(char c : p.toCharArray()){
            recordP[c]++;
        }
        int pointLeft = 0;
        int PointRight = pointLeft+len-1;
        char[] charS = s.toCharArray();
        boolean flag = false;
        while(PointRight<s.length()){
            int[] recordS = new int[256];
            for(int i=pointLeft;i<=PointRight;i++){
                recordS[charS[i]]++;
            }
            for(int j=0;j<256;j++){
                if(recordS[j]!=recordP[j]){
                    flag=true;
                    break;
                }
            }
            if(flag){
                recordS = new int[256];
                flag=false;
            }else{
                res.add(pointLeft);
            }
            pointLeft++;
            PointRight = pointLeft+len-1;
        }
        return res;
    }
}
```















