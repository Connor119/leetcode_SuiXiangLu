# 数组专题

#### 数组的基础知识

定义：数组是存放在连续内存空间上的相同类型数据的集合

- 数组下标都是从0开始的
- 数组内空间地址是连续的
- 正是因为数组的内存空间地址是连续的，所以我们在删除或者添加元素的适合，无法避免移动其它元素





#### 二分查找类型题

##### 题目1（leetcode 704）

- 排序数组
- 查找元素

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220424145732827.png" alt="image-20220424145732827" style="zoom: 80%;" />

```java
写法1
class Solution {
    public int search(int[] nums, int target) {
        int left=0;
        int right=nums.length-1;
        while(right>=left){
            int mid = (left+right)/2;
            if(nums[mid]<target){
                left = mid+1;
            }else if(nums[mid]>target){
                right=mid-1;
            }else{
                return mid;
            }
        }
        return -1;
    }
}
```

- 二分查找的两种写法

  这两个写法的区别在于循环终止条件和右指针是移动到mid位置还是移动到其前一个

  - 左右都闭合（左指针和右指针都指在元素本身）
    - 在这种写法中，如果两个指针都指向同一元素，那么这个元素也是要被搜寻的（例如遍历单元素数组的时候，左右指针都指向第一个元素，这时候也要进入循环进行结果的判断）并且如果中间元素不是target的话需要将右指针指向mid的前一个，因为mid已经被检验完成了
      - **这里循环的终止条件应该是while (left <= right) 要使用 <=**
      - **这里的右指针移动需要将其移动到mid的下一个**
  - 左闭右开（左指针指向的是元素本身，右指针指向的是所有元素的下一个）
    - 在这种写法中，右指针指向的元素永远是有效元素的后一个，所以当左指针和右指针相碰，这就说明并没有有效的搜索集了，并且当mid并不等于target的时候，我们也要保持在有效搜索范围外一个的位置上定义我们的右指针
      - **while (left < right)，这里使用 <**
      - **if (nums[middle] > target) right 更新为 middle**

  

```java
写法2
class Solution {
    public int search(int[] nums, int target) {
        int left=0;
        int right=nums.length;
        while(right>left){
            int mid = (left+right)/2;
            if(nums[mid]<target){
                left = mid+1;
            }else if(nums[mid]>target){
                right=mid;
            }else{
                return mid;
            }
        }
        return -1;
    }
}
```

**从这比较中可以看出来，定义右指针的方式不同，循环结束条件不同，右指针移动的时候的位置不同（三不同）**



##### 题目2: 35搜索插入位置

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220424154416512.png" alt="image-20220424154416512" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220424154537055.png" alt="image-20220424154537055" style="zoom:80%;" />

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length-1;
        while(left<=right){
            int mid = (left+right)/2;
            if(nums[mid]<target){
                left = mid+1;
            }else if(nums[mid]>target){
                right = mid-1;
            }else{
                return mid;
            }
        }
        return left;
    }
}
```

**与上面不一样的就是返回值**

在双闭合写法的时候，当搜寻结束时，右指针会在左指针的左侧（只能返回左）。

而在单闭合写法的时候，最后结束的时候就时左右指针重合（所以返回左还是右都可以）



#### 移除元素

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220425142044037.png" alt="image-20220425142044037" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220425142056729.png" alt="image-20220425142056729" style="zoom:80%;" />

##### 题目1（leetcode 27）快慢指针类型题

慢指针指向的是返回数据集的右边界，快指针遍历数据集中的每一个元素，当快指针指向的元素和val不一样的时候，将右边界指向的元素和当前元素调换，之后右边界往后扩一个。如果一样则右边界不动继续找下一个与val不一样的元素。

这道题的右边界思想和二分查找解法的第二种解法相同。我们右边界定位0的时候，这时候叫右边界（返回数据集的右边的一个位置）当右边界为-1的时候，这时候才是指向的元素

**解法1：右边界解法（返回数据集的下一个位置）**

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int returnIndex = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]!=val){
                swep(nums,returnIndex,i);
                returnIndex++;
            }
        }
        return returnIndex;
    }
    public void swep(int[] nums,int index1,int index2){
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp; 

    }
}
```

**解法2：右指向返回集合的最后一个元素**

与上一种对比，当一开始的时候，我们的慢指针不能指向0位置，因为0位置上的数我们并不知道是否要返回。而是要指向-1位置，因为-1位置才是我们要返回数据集中的第一个数

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int returnIndex = -1;
        for(int i=0;i<nums.length;i++){
            if(nums[i]!=val){
                swep(nums,returnIndex+1,i);
                returnIndex++;
            }
        }
        return returnIndex+1;
    }
    public void swep(int[] nums,int index1,int index2){
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp; 

    }
}
```

##### 题目2（leetcode844）比较含退格字符串

这道题中的思想就是，字符串和数组是一样的东西，都是连续存储空间的一种数据结构

这道题比上一题多了一个往后退的思想，当遇到#的时候，就得让选中区域往后移动一个格。但是要注意，当已经不能移动的时候就不要移动它了，

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220425154135837.png" alt="image-20220425154135837" style="zoom:80%;" />

```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        char[] s1 = s.toCharArray();
        char[] s2 = t.toCharArray();
        int indexS1=0;
        int indexS2=0;
        indexS2=stringChange(s2,indexS2);
        indexS1=stringChange(s1,indexS1);
        
        if(indexS1==indexS2){
            for(int i=0;i<indexS1;i++){
                if(s1[i]!=s2[i]){
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    public void swep(char[] nums,int index1,int index2){
        char temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp; 

    }
    public int stringChange(char[] s1,int indexS1){
       for(int i=0;i<s1.length;i++){
            if(s1[i]=='#'&&indexS1!=0){
                indexS1--;
            }else{
                swep(s1,indexS1,i);
                indexS1++;
            }
        }
        return indexS1;
    }
}
```















